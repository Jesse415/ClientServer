# ClientServer
This is a program that is a Client and a Server program in one

# Problem Statement
  The goal of this project is to make two programs, one that is a client, and the other
  that is the server. The client connects to the server and is able to send commands to
  the server. These commands can be to get the information about the system that the server
  is located. Also, acceptance of files and to send files to the server. This is all done 
  though TCP port connecting through the local host.

# User Requirements
  1. The user should be able to connect the client to the server after the server is running.
  2. Multiple clients can connect to the server at one time.
  3. Once client is connected, they will be met with a connection successful message and a 
     command line menu as to accepted commands based on what actions the client wished to 
     take.
  4. For commands with directories as inputs, the user must put the absolute path to get the
     results.

# Software Requirements
  1. Using a socket connection, the client program will query the remote server program that is
     listening on port 80
  2. The IP address of the server to be queried bu the client shall be given to the client as a
     command line argument.
  3. The client shall wait for the user to enter queries (via stdin), which it then forwards to the
     server in a loop until the user types 'quit'. Any responses from the server are immediately displayed
     to the user.
  4. The client will report the time taken for the server to respond to each query together with the
     server's response.
  5. The client is non-blocking. An infinite number of server queries may be outstanding.
  6. The server will spawn a new process to execute each new request and must be able to accept multiple clients.
  7. The server will be able to accept one or more source files and a 'progname' and place the file in a
     directory called 'progname'. It will be able to compile the source files (if not previously compiled),
     run the executable with command line arguments provided from the client and return the result to the clients.
  8. The source code shall be portable so that it can be compiled and run on both UNIX and Windows.
  9. The following query commands (and options) are to be recognized by the server (anything within [] is optional):
     1. put progname sourcefile[s] [-f]: upload sourcefiles to progname dir, -f overwrite if exists.
     2. get progname sourcefile: download sourcefile from progname dir to client screen.
     3. run progname [args] [-f localfile] : compile (if req.) and run the executable (with args) and either print
        the return results to screen or given local file.
     4. list [-l] [progname] : list the progname on the server or files in the given progname directory to the screen,
        -l = long list
     5. sys : return the name and version of the Operating System and CPU type.
  10. The long list (-l) option of the list command will also return the file size, creation date and access permissions.
      If no progname is given, then the list of all available progname directories will be returned.
  11. The get command will dump the file contents to the screen 40 lines at a time and pause, waiting for a key to be
      pressed before displaying the next 40 lines etc.
  12. The put command will create a new directory on the server called 'progname' If the remote progname exists the server
      will return an error, unless -f has been specified, in which case the directory will be completely overwritten (old
      content is deleted). This command allows you to upload one or more file from the client to the server.
  13. If a localfile option is given to the run command a new file on the client will be created, If the localfile name exists
      the client will return an error, unless -f has been specified in which case the file will be overwritten. If a file with
      that name already exists the client will return an error before sending the get request to the server.
  14. The run command will check to see if a 'progname' has been compiled, and if not will compile the relevant file as require.
      Run will initiate a compile if these is no executable in the folder, or its creation date is older than the last modified
      date of a source file. It will then run the executable, passing to it an specified command line arguments, and the server
      will redirect output from the executed program to the client. If the program can't be run (or compiled) an appropriate 
      error will be returned to the client. You must not use the system() call to compile or run the 'progname'.
  15. If the server receives an incorrectly specified command it will return an error. If the server is unable to execute a valid
      command the server will return the error string generated by the operating system to the client.
  16. All Zombie processes are terminated as required. There is to be no unwanted Zombie processes on either the client, or
      the server.


# User Instructions
  
  To use follow these easy steps:

  1. Run ~make~ inside the server directory and inside the client directory
     from the command line.
  2. Run ~./server~ first in one terminal. 
  3. Run ~./client~ on another. 
  4. Here you can follow the command prompt message how it is displayed.
  5. Any wrong inputs will send you an error and ask you to try again.

